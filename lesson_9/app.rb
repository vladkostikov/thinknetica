# frozen_string_literal: true

# Изначальный код взят из 8 урока
# Задание:
# 1. Написать модуль, содержащий 2 метода, которые можно вызывать на уровне класса:
# 1.1 attr_accessor_with_history
# Динамически создает геттеры и сеттеры для любого количества атрибутов.
# При этом сеттер сохраняет все значения инстанс-переменной при изменении
# этого значения.
# Также должен быть метод <имя_атрибута>_history, который возвращает массив
# всех значений данной переменной.
# 1.2 strong_attr_accessor
# Принимает имя атрибута и его класс.
# При этом создается геттер и сеттер для одноименной инстанс-переменной,
# но сеттер проверяет тип присваемоего значения.
# Если тип отличается от того, который указан вторым параметром,
# то выбрасывается исключение.
# Если тип совпадает, то значение присваивается.
#
# 2. Написать модуль Validation, который:
# 2.1 Содержит метод класса validate
# Этот метод принимает в качестве параметров имя проверяемого атрибута,
# а также тип валидации и при необходимости дополнительные параметры.
# Возможные типы валидаций:
# 2.1.1 presence
# Требует, чтобы значение атрибута было не nil и не пустой строкой.
# Пример: validate :name, :presence
# 2.1.2 format
# Принимает отдельным параметром регулярное выражение для формата.
# Требует соответствия значения атрибута заданному регулярному выражению.
# Пример: validate :number, :format, /A-Z{0,3}/
# 2.1.3 type
# Требует соответствия значения атрибута заданному классу.
# Пример: validate :station, :type, RailwayStation
#
# 2.2 Содержит инстанс-метод validate!
# Метод запускает все проверки (валидации), указанные в классе через
# метод класса validate.
# В случае ошибки валидации выбрасывает исключение с сообщением о том,
# какая именно валидация не прошла.
#
# 2.3 Содержит инстанс-метод valid?
# Метод возвращает true, если все проверки валидации прошли успешно.
# Или возвращает false, если есть ошибки валидации.

require_relative 'modules/interface'

include Interface

Interface.start
